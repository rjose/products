QPlan v4
========
Rino Jose <@rjose>
v2, Jul 1, 2013: Finished step 1

Drafting effort [][]

Overview
--------
The goal of this version is to have QPlan listen for web requests and serve web
pages. The first step is to organize our lua code into app code and modules. The
next step is to bring over the code that can listen and respond to web
requests. After that, we'll pull the lua web request parsing/routing code into a
web module. Finally, we'll create some pages using angular to serve content.

Implementation
--------------

.
link:https://github.com/rjose/products/tree/98c7b/qplan/v4[
      Organize lua and C code]
      [X][X][X][X][X]
. Listen and respond to web requests [X][X][X][][][]
. Create angular pages [X][X][X][][][][][]
. Add staff page [X][][][]
. Add readline support [][][][][]


1 - Organize lua and C code
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We should use qplan-c/proto2 as a model here. We'll copy the lua code from
qplan/v2 and see if we can get it running through our custom shell. Let's start
by getting the custom shell running first. Hmmmm. Forgot to check in the
tcp_io.[ch] changes I made. I guess I'll just have to code it up again. These
were just minor changes (function renaming). Alright, I got it to build. Let's
copy the app code over. Done. Let's check this in.

Alright, let's start cleaning some things up. I don't like the global pl and ppl
variables. We should clean these up when we start in on the qplan language. How
about we start by splitting out the repl and web parts of the qplan.c file out.
We should document these as well. I want to only have one lua state for now and
have a lock around that. Done. Alright, let's split out the QPlanContext into
its own files. We'll leave "err_abort" in qplan.c until we have enough utils to
pull it out. After that, we'll create repl and web C files. Done!

OK, next up is bringing up the lua functions from qplan_web. I want to bring the
tests over for these as well. Let's see what would happen with a web request
now. I think we'll get an error on the handle_request call. We got an
unprotected call and died. Let's see if we can make this a protected call. Hmmm.
Not sure how to do this. I did fix this, though, by calling "lua_setglobal"
after the web module was required to set "web".

What we'll do next is bring the request parser over and see if we can
understand the requests. I want to make sure we bring the tests over first,
though. Alright, the request parser tests are over and running. Let's hook up
this up to the handle_request function. Hmmm. I keep getting a core dump when a
web request executes an invalid instruction. I need to fix this. In any case, I
was able to parse a web request! Let's spend a pomodoro on the core dump. If I
can't get that working, let's move to routing the request.

I think the problem is that we're not calling the function as a global function.
Let's expose this and see what happens. OK, that wasn't it. It looks like when
something went wrong, I kept going. Should've gone to an error condition
instead. Let's check this in, but then revert to the nonglobal version and see
if it still works. Yup. Let's check in and then go on to routing (which is
properly the next prototype).

2 - Listen and respond to web requests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Alright, now that we've gotten requests parsed, let's route them to other
functions for handling. I'll bring over the tests first and then hook things up.
Done. Let's check in. So where do we hook things up? It's got to be in
handle_request right after we parse the request. OK, was able to return a web
page. Cool. Let's check in.

The next step was to add a lua web module, but I think that should be done here
instead. Let's pull the app module out of the request router and into the web
module. Any json requests should come through here. I'll follow the conventions
for how angular pages work.


3 - Create angular pages
~~~~~~~~~~~~~~~~~~~~~~~~
OK, the next thing we should do is start creating some web pages. I'll follow
along with the angular tutorial. I think it may make sense for me to do this
work on my mac. Let's check this out over there. I wonder if I can do some
development there, mocking out the responses and then hooking them up later?
Alright, I added the todo content, and it appears to be working.

There are a couple of things that I need to understand. Is angular supposed to
supplant jquery? (A: I believe so. It's a different mental model). How do I make
an ajax request? (A: there's an $http service with callbacks).

I think what I want to do is to have an index.html page that show an overview of
the quarterly plan. There should be links to static pages like people and
reports by track. I'll try to get this work done without doing a prototype. If
I run into issues, though, I'll drop out of here and do an exploratory
prototype.

Alright, let's start by creating our nav elements and our basic pages. How
does angular handle nav elements? I'm going to just do some copy/paste for
now. After it works, I'll circle back.

I've created a bunch of (mostly) empty pages. Let's see if we can get a list
of staff back. Actually, let me break this out as its own implementation step.

4 - Add staff page
~~~~~~~~~~~~~~~~~~
I've been able to render some data using a StaffCtrl. Let's see if I can make
the ajax request to actually get the data from QPlan. Alright, I was able to
do this from within the StaffCtrl function. I think I'd like the flexibility
to call this explicitly. I'll do this after I get some data back.

Thoughts
--------
I should learn how to do TDD with angular. I should examine the angular-seed app
to see if there's anything I can learn about organizing the source files.

Here are some things I wanted to do:

- Review memory management in our C files
- Add readline support
