QPlan v4
========
Rino Jose <@rjose>
v2, Jul 1, 2013: Finished step 1

Drafting effort [][]

Overview
--------
The goal of this version is to have QPlan listen for web requests and serve web
pages. The first step is to organize our lua code into app code and modules. The
next step is to bring over the code that can listen and respond to web
requests. After that, we'll pull the lua web request parsing/routing code into a
web module. Finally, we'll create some pages using angular to serve content.

Implementation
--------------

.
link:https://github.com/rjose/products/tree/98c7b/qplan/v4[
      Organize lua and C code]
      [X][X][X][X][X]
. Listen and respond to web requests [][][][][][]
. Add lua web module [][][][]
. Create angular pages [][][][][][][][]
. Add readline support [][][][][]


1 - Organize lua and C code
~~~~~~~~~~~~~~~~~~~~~~~~~~~
We should use qplan-c/proto2 as a model here. We'll copy the lua code from
qplan/v2 and see if we can get it running through our custom shell. Let's start
by getting the custom shell running first. Hmmmm. Forgot to check in the
tcp_io.[ch] changes I made. I guess I'll just have to code it up again. These
were just minor changes (function renaming). Alright, I got it to build. Let's
copy the app code over. Done. Let's check this in.

Alright, let's start cleaning some things up. I don't like the global pl and ppl
variables. We should clean these up when we start in on the qplan language. How
about we start by splitting out the repl and web parts of the qplan.c file out.
We should document these as well. I want to only have one lua state for now and
have a lock around that. Done. Alright, let's split out the QPlanContext into
its own files. We'll leave "err_abort" in qplan.c until we have enough utils to
pull it out. After that, we'll create repl and web C files. Done!

OK, next up is bringing up the lua functions from qplan_web. I want to bring the
tests over for these as well. Let's see what would happen with a web request
now. I think we'll get an error on the handle_request call. We got an
unprotected call and died. Let's see if we can make this a protected call. Hmmm.
Not sure how to do this. I did fix this, though, by calling "lua_setglobal"
after the web module was required to set "web".

What we'll do next is bring the request parser over and see if we can
understand the requests. I want to make sure we bring the tests over first,
though. Alright, the request parser tests are over and running. Let's hook up
this up to the handle_request function. Hmmm. I keep getting a core dump when a
web request executes an invalid instruction. I need to fix this. In any case, I
was able to parse a web request! Let's spend a pomodoro on the core dump. If I
can't get that working, let's move to routing the request.

I think the problem is that we're not calling the function as a global function.
Let's expose this and see what happens. OK, that wasn't it. It looks like when
something went wrong, I kept going. Should've gone to an error condition
instead. Let's check this in, but then revert to the nonglobal version and see
if it still works. Yup. Let's check in and then go on to routing (which is
properly the next prototype).

2 - Listen and respond to web requests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Alright, now that we've gotten requests parsed, let's route them to other
functions for handling. I'll bring over the tests first and then hook things up.
Done. Let's check in. So where do we hook things up? It's got to be in
handle_request right after we parse the request. OK, was able to return a web
page. Cool. Let's check in.

Thoughts
--------
